import { jsx, jsxs } from 'react/jsx-runtime';
import { Typography, Flex, Box, IconButton } from '@strapi/design-system';
import { ThumbUp, ThumbDown } from '@strapi/icons';
import Markdown from 'react-markdown';
import { styled } from 'styled-components';
import { useFeedbackModal } from '../../FeedbackModal.mjs';
import { useFeedback } from '../../hooks/useFeedback.mjs';
import { AnimatedBox } from '../AnimatedBox.mjs';
import { AttachmentPreview } from '../Attachments/AttachmentPreview.mjs';
import { Marker } from './Marker.mjs';

const MarkdownStyles = styled(Typography)`
  max-width: 65ch;
  margin: 0 auto;

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    margin-top: 1.25em;
    margin-bottom: 0.5em;
    font-weight: bold;
  }

  p {
    margin-bottom: 1em;
  }

  ul,
  ol {
    padding-left: 1.5em; /* indentation for bullet points */
    margin-bottom: 1em;
  }

  li {
    margin-bottom: 0.5em;
    list-style-type: disc; /* or whatever style you prefer */
  }

  strong {
    font-weight: bold;
  }

  /* code blocks, blockquotes, etc. */
  code {
    background-color: ${({ theme })=>theme.colors.neutral100};
    padding: 0.2em 0.4em;
    border-radius: ${({ theme })=>theme.borderRadius};
    border-color: ${({ theme })=>theme.colors.neutral150};
    border-style: solid;
    font-family: 'SF Mono', SFMono-Regular, ui-monospace, 'DejaVu Sans Mono', Menlo, Consolas,
      monospace;
  }

  /* links */
  a {
    color: ${({ theme })=>theme.colors.primary500};
    background-color: ${({ theme })=>theme.colors.neutral100};
    padding: 0.2em 0.4em;
    border-radius: ${({ theme })=>theme.borderRadius};
    border-color: ${({ theme })=>theme.colors.neutral150};
    border-style: solid;
    text-decoration: none;

    &:hover {
      text-decoration: underline;
    }
  }
`;
const isSchemaToolPart = (part)=>part && typeof part === 'object' && part.type === 'tool-schemaGenerationTool';
const capitalize = (s)=>s ? s.charAt(0).toUpperCase() + s.slice(1) : '';
const getSchemaLink = (schema)=>{
    const isComponent = (schema.kind ?? schema.modelType) === 'component';
    if (!schema.uid) return undefined;
    return isComponent ? `/plugins/content-type-builder/component-categories/${schema.category ?? ''}/${schema.uid}` : `/plugins/content-type-builder/content-types/${schema.uid}`;
};
const toMarkerFromSchemaTool = (part)=>{
    const outSchemas = part.output?.schemas ?? [];
    const inSchemas = part.input?.schemas ?? [];
    const schemas = outSchemas.length ? outSchemas : inSchemas;
    const numSchemas = schemas.length;
    const state = part.output ? part.output.error ? 'error' : 'success' : 'loading';
    const steps = schemas.map((schema, index)=>({
            id: `${part.toolCallId ?? 'schemaGenerationTool'}-${schema.uid ?? schema.name ?? index}`,
            description: capitalize(schema.name ?? schema.uid ?? 'Schema'),
            status: schema.action === 'create' || schema.action === 'update' || schema.action === 'remove' ? schema.action : 'update',
            link: getSchemaLink(schema)
        }));
    const title = state === 'success' ? `Updated ${numSchemas} schema${numSchemas === 1 ? '' : 's'}` : state === 'error' ? `Failed to update schema${numSchemas === 1 ? '' : 's'}` : 'Updating schemas';
    return {
        type: 'marker',
        title,
        state,
        steps
    };
};
const MessageContent = ({ part })=>{
    if (part.type === 'text') {
        return /*#__PURE__*/ jsx(MarkdownStyles, {
            children: /*#__PURE__*/ jsx(Markdown, {
                components: {
                    a: ({ node, ...props })=>/*#__PURE__*/ jsx("a", {
                            target: "_blank",
                            rel: "noopener noreferrer",
                            ...props
                        })
                },
                children: part.text
            })
        });
    }
    if (isSchemaToolPart(part)) {
        const marker = toMarkerFromSchemaTool(part);
        return /*#__PURE__*/ jsx(Marker, {
            ...marker
        });
    }
    return null;
};
const UserMessage = ({ message })=>{
    const hasText = message.parts.some((content)=>content.type === 'text' && content.text.trim() !== '');
    const attachments = message.parts.filter((content)=>content.type === 'file');
    return /*#__PURE__*/ jsxs(AnimatedBox, {
        as: Flex,
        direction: "column",
        alignItems: "flex-end",
        style: {
            alignSelf: 'flex-end'
        },
        gap: 2,
        maxWidth: "80%",
        children: [
            hasText ? /*#__PURE__*/ jsx(Box, {
                background: "neutral150",
                borderStyle: "none",
                padding: [
                    '10px',
                    '16px'
                ],
                hasRadius: true,
                children: message.parts.map((content, index)=>{
                    if (content.type !== 'text') return null;
                    return /*#__PURE__*/ jsx(Typography, {
                        children: content.text
                    }, index);
                })
            }) : null,
            attachments.map((attachment, idx)=>/*#__PURE__*/ jsx(AttachmentPreview, {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    attachment: {
                        ...attachment,
                        status: 'ready'
                    }
                }, `${attachment.type === 'file' ? attachment.filename : attachment.type}-${idx}`))
        ]
    });
};
const AssistantMessage = ({ message, isLoading })=>{
    const { upvoteMessage } = useFeedback();
    const { openFeedbackModal } = useFeedbackModal();
    return /*#__PURE__*/ jsxs(Box, {
        style: {
            alignSelf: 'flex-start'
        },
        maxWidth: "90%",
        children: [
            message.parts.map((content, index)=>/*#__PURE__*/ jsx(MessageContent, {
                    part: content
                }, index)),
            isLoading ? /*#__PURE__*/ jsxs(Flex, {
                gap: 1,
                children: [
                    /*#__PURE__*/ jsx(IconButton, {
                        label: "Upvote",
                        size: "XS",
                        variant: "ghost",
                        onClick: ()=>upvoteMessage(message.id),
                        children: /*#__PURE__*/ jsx(ThumbUp, {})
                    }),
                    /*#__PURE__*/ jsx(IconButton, {
                        label: "Downvote",
                        size: "XS",
                        variant: "ghost",
                        // For downvoting, user must provide specific feedback
                        onClick: ()=>openFeedbackModal(message.id),
                        children: /*#__PURE__*/ jsx(ThumbDown, {})
                    })
                ]
            }) : null
        ]
    });
};
const ChatMessage = ({ message, isLoading })=>{
    /**
   * IMPORTANT: Messages are rendered using react-markdown (heavy compute)
   * Component re-renders on each message update, but AI SDK v5 provides
   * throttling (experimental_throttle: 100ms) which batches updates and reduces
   * re-render frequency during streaming.
   */ if (message.role === 'user') {
        return /*#__PURE__*/ jsx(UserMessage, {
            message: message
        });
    }
    return /*#__PURE__*/ jsx(AssistantMessage, {
        message: message
    });
};

export { ChatMessage };
//# sourceMappingURL=Message.mjs.map
